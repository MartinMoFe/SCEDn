local CoroutineLib                  = require("util/CoroutineLib")
local MythosAreaApi                 = require("mythos/MythosAreaApi")
local DeckLib                       = require("util/DeckLib")
local GlobalApi                     = require("Global/GlobalApi")
local GUIDReferenceApi              = require("core/GUIDReferenceApi")
local PlayAreaApi                   = require("playarea/PlayAreaApi")
local PlayermatApi                  = require("playermat/PlayermatApi")
local SearchLib                     = require("util/SearchLib")
local TokenArrangerApi              = require("tokens/TokenArrangerApi")
local TokenSpawnTrackerApi          = require("tokens/TokenSpawnTrackerApi")
local VictoryDisplayApi             = require("mythos/VictoryDisplayApi")

local FIRST_BUTTON_POSITION         = Vector(0, 1, -1.5)
local DELTA                         = Vector(0, 0, 1)
local ONE_CARD_HELPER_TEMPLATE_GUID = "3592d8"
local EXPLORE_HELPER                = "8355c3"
local COLOR_BLUE                    = { 0.5, 0.5, 1 }
local COLOR_RED                     = { 0.8, 0.3, 0.3 }
local ROTATION_VERTICAL             = { 0, 270, 0 }
local ROTATION_HORIZONTAL           = { 0, 180, 0 }
local SET_ASIDE_POSITION_2          = { x = -8.56, y = 1.53, z = 2 }

function onLoad()
  helpersVisible = false
  printedSymbols = false
  indexes = {}
  act3done = false

  local buttonPosition = FIRST_BUTTON_POSITION
  self.createButton({
    label = "Highlight Ancient Locations in play",
    click_function = "highlightAncient",
    function_owner = self,
    position = buttonPosition,
    rotation = { 0, 0, 0 },
    width = 2500,
    height = 300,
    font_size = 150,
    color = COLOR_BLUE,
    font_color = { 1, 1, 1 },
    tooltip = ""
  })
  buttonPosition = buttonPosition + DELTA
  self.createButton({
    label = "Replace explored location",
    click_function = "toggleIndividualHelpers",
    function_owner = self,
    position = buttonPosition,
    rotation = { 0, 0, 0 },
    width = 2500,
    height = 300,
    font_size = 150,
    color = COLOR_BLUE,
    font_color = { 1, 1, 1 },
    tooltip = ""
  })
  buttonPosition = buttonPosition + DELTA
  self.createButton({
    label = "Print symbols on table",
    click_function = "toggleMarkSymbols",
    function_owner = self,
    position = buttonPosition,
    rotation = { 0, 0, 0 },
    width = 2500,
    height = 300,
    font_size = 150,
    color = COLOR_BLUE,
    font_color = { 1, 1, 1 },
    tooltip = ""
  })
  buttonPosition = buttonPosition + DELTA
  self.createButton({
    label = "Agenda 2b, follow instructions",
    click_function = "placeActAgenda3",
    function_owner = self,
    position = buttonPosition,
    rotation = { 0, 0, 0 },
    width = 2500,
    height = 300,
    font_size = 150,
    color = { 0.5, 0.6, 0.9 },
    font_color = { 1, 1, 1 },
    tooltip = ""
  })
  onLoadTests()
end

-- Clicked functions

function highlightAncient(_, playerColor)
  -- Search for Ancient locations
  local ancientLocations = {}
  for _, obj in ipairs(getLocations('Ancient')) do
    obj.highlightOn('White', 5)
    table.insert(ancientLocations, obj)
  end
  if #ancientLocations > 0 then
    printToAll('There are ' .. tostring(#ancientLocations) .. ' Ancient locations.')
  end
end

function toggleIndividualHelpers(_, playerColor)
  -- Search for present-day locations
  if helpersVisible == false then
    for _, obj in ipairs(getLocations('Present')) do
      createOneHelper(obj)
      self.editButton({
        index = 1,
        label = "Hide Locations Helper",
        color = COLOR_RED
      })
    end
  elseif helpersVisible == true then
    removeAllHelper()
    self.editButton({
      index = 1,
      label = "Replace explored location",
      color = COLOR_BLUE
    })
  end

  helpersVisible = not helpersVisible
end

function placeActAgenda3(_, playerColor)
  function placeActAgenda3coroutine()
    if act3done then
      printToAll('Button was already clicked')
      return
    end
    local chest = MythosAreaApi.getSetAsideChest() or nil
    if not chest then
      print("Chest not found")
      return
    end

    local exploreHelper = getObjectFromGUID(EXPLORE_HELPER)
    if not exploreHelper then
      printToAll('Explore helper not found. Setup aborted.', 'Red')
    end
    local explorationDeck = getExplorationDeck(exploreHelper)
    if not explorationDeck then
      printToAll('Exploration deck was not found. Setup aborted.', 'Red')
    end

    -- find the bag inside the chest
    local chestContents = chest.getObjects()
    if #chestContents == 0 then
      print("Set-Aside Chest is empty")
      return
    end

    local bagData = nil
    for _, data in ipairs(chestContents) do
      if data.nickname == "Agenda 3 & Act 3" then
        bagData = data
        break
      end
    end

    if not bagData then
      print("Bag not found inside chest")
      return
    end

    local trash = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "Trash")
    if not trash then
      print('Trash not found')
      return
    end
    aboveTrash   = trash.getPosition() + Vector(0, 0.8, 0)

    -- We are ready

    act3done     = true

    -- Take out the bag near a reference position { x = 0, y = 2.5 }. Tint the bag white (it is black against black)
    local bagObj = chest.takeObject({
      guid = bagData.guid,
      position = PlayAreaApi.gridToWorld({ x = 0, y = 2.5 }),
      smooth = true
    })
    bagObj.setColorTint({ r = 1, g = 1, b = 1 })

    -- Start the card instructions. Find each Location in play
    -- █▀█ █▀▀ █▀▄▀█ █▀▀ █▀▄▀█ █▄▄ █▀▀ █▀█
    -- █▀▄ ██▄ █░▀░█ ██▄ █░▀░█ █▄█ ██▄ █▀▄

    local symbolPosition = {}

    -- █▀█ █▀▀ █▀▄▀█ █▀█ █░█ █▀▀   ▀█▀ █▀█   █░█ █ █▀▀
    -- █▀▄ ██▄ █░▀░█ █▄█ ▀▄▀ ██▄   ░█░ █▄█   ▀▄▀ █ █▄▄

    local ancientLocations = getLocations('Ancient')
    for _, location in ipairs(ancientLocations) do
      if not cardHasClues(location) then
        local thingsAbove = SearchLib.onObject(location)
        liftObjects(thingsAbove)
        -- update the rembering list
        symbolPosition[getSymbol(location)] = location.getPosition()
        PlayAreaApi.maybeUntrackLocation(location)
        VictoryDisplayApi.placeCard(location)
        printToAll(location.getName() .. ' was placed on the Victory Display.')
        CoroutineLib.yieldSeconds(0.5)
      else
        message = "This card has still some clues, we don't remove it: " .. location.getName()
        log(message)
      end
    end

    CoroutineLib.yieldSeconds(0.5)

    -- █▀█ █▀▀ █▀▄▀█ █▀█ █░█ █▀▀   █▀█ █▀█ █▀▀ █▀ █▀▀ █▄░█ ▀█▀
    -- █▀▄ ██▄ █░▀░█ █▄█ ▀▄▀ ██▄   █▀▀ █▀▄ ██▄ ▄█ ██▄ █░▀█ ░█░
    local presentLocations = getLocations('Present')
    for _, location in ipairs(presentLocations) do
      local thingsAbove = SearchLib.onObject(location)
      liftObjects(thingsAbove, 4)
      symbolPosition[getSymbol(location)] = location.getPosition()
      PlayAreaApi.maybeUntrackLocation(location)
      location.setPositionSmooth(SET_ASIDE_POSITION_2)
      CoroutineLib.yieldSeconds(0.2)
      printToAll(location.getName() .. ' was placed aside.')
      -- update the rembering list
    end

    -- search the exploration deck for a location with a matching location symbol
    -- in the upper-left corner and place it on top of that location, taking its place.

    for symbol, position in pairs(symbolPosition) do
      log('Searching ' .. symbol)
      local success = false
      for _, obj in ipairs(explorationDeck.getObjects()) do
        local symbol2 = getSymbol(obj)
        if symbol2 == symbol then
          explorationDeck.takeObject({ guid = obj.guid, position = position, rotation = ROTATION_VERTICAL })
          success = true
          break
        end
      end
      if not success then
        log('Couldnt find the ' .. symbol .. ' in the exploration deck.')
      end
    end

    CoroutineLib.yieldSeconds(0.5)
    -- Remove Act deck and Agenda deck
    local agendaPos = MythosAreaApi.getAgendaPosition()
    local search1 = SearchLib.atPosition(agendaPos, "isCardOrDeck")
    local actPos = MythosAreaApi.getActPosition()
    local searc2 = SearchLib.atPosition(actPos, "isCardOrDeck")
    for _, objects in ipairs({ search1, searc2 }) do
      for j, object in ipairs(objects) do
        object.setPositionSmooth(aboveTrash)
        object.setRotationSmooth(ROTATION_HORIZONTAL)
      end
    end

    -- wait until the bag is on the table
    Wait.condition(function()
      if not bagObj then
        print("Inner object is not a bag")
        return
      end

      -- now inspect the bag contents
      local bagContents = bagObj.getObjects()
      for _, item in ipairs(bagContents) do
        if item.nickname == "The Return Trip" then
          bagObj.takeObject({
            guid     = item.guid,
            position = MythosAreaApi.getActPosition(),
            smooth   = true
          })
        elseif item.nickname == "Time Collapsing" then
          local dest = getObjectFromGUID("652ff3").getPosition()
          bagObj.takeObject({
            guid     = item.guid,
            position = MythosAreaApi.getAgendaPosition(),
            smooth   = true
          })
        end
      end
    end, function() return bagObj.resting end) -- wait until the bag is placed

    printToAll("Placed new Act 3 and Agenda 3.")

    -- █▀█ ▄▀█ █▀▄ █▀▄▀█ █▀▀
    -- █▀▀ █▀█ █▄▀ █░▀░█ ██▄

    local success = false
    local chestContents2 = chest.getObjects()
    for _, data in ipairs(chestContents2) do
      if data.nickname == "Padma Amrita" then
        local targetPos = symbolPosition['Circle']
        if targetPos then
          local targetPos = {
            x = targetPos.x,
            y = targetPos.y + 4,
            z = targetPos.z + 2.4
          }

          chest.takeObject({
            guid     = data.guid,
            position = targetPos,
            rotation = ROTATION_VERTICAL,
            smooth   = true,
            flip     = false
          })
        end
        success = true
        break -- stop after finding Padma Amrita
      end
    end
    if success then printToAll('Padme was not found in the Set-Aside chest.') end
    printToAll('Lose all your clues.', 'Green')
  end

  CoroutineLib.start(placeActAgenda3coroutine)
end

function toggleMarkSymbols(_, playerColor)
  -- Remove lines
  if printedSymbols == true then
    removeLines(indexes)
    printedSymbols = false
    self.editButton({
      index = 2,
      label = "Print symbols on table",
      color = COLOR_BLUE
    })
    return
  end

  for _, object in ipairs(getLocations()) do
    local symbol = getSymbol(object)
    local pos = object.getPosition()
    if symbol ~= nil then
      newIndexes = drawSymbol(pos, symbol)
      indexes = append(indexes, newIndexes)
    end
  end

  printedSymbols = true
  self.editButton({
    index = 2,
    label = "Remove symbols on table",
    color = COLOR_RED
  })
end

-- Create and destroy helpers

function createOneHelper(card)
  local template = getObjectFromGUID("3592d8")
  local helper = template.clone({
    position = card.getPosition() + Vector(0, 0.5, 0)
  })
  helper.interactable = false

  helper.addTag("BoundaryHelper")

  Wait.frames(function()
    if helper then
      helper.call("init", card)
    end
  end, 2)
  return helper
end

function removeAllHelper()
  local this
  this = getAllObjects()
  for _, el in ipairs(this) do
    if el.hasTag('BoundaryHelper') then
      el.destruct()
    end
  end
end

-- Helper functions

function drawSymbol(pos, symbol)
  assert(type(pos) == 'table', 'Type error in drawSymbol')
  assert(type(symbol) == 'string', 'Type error in drawSymbol')


  local lineIndexes = {}

  local center = { x = pos.x, y = pos.y, z = pos.z }

  local thickness = 0.1
  local color = { 1, 1, 0 }

  local allLines = Global.getVectorLines() or {}

  local function addLine(line)
    table.insert(allLines, line)
    table.insert(lineIndexes, #allLines)
  end

  if symbol == 'Star' then
    color = 'Grey'
    local radius = 2
    local points = {}
    for i = 0, 4 do
      local angle = math.rad(72 * i - 90)
      local px = center.x + radius * math.cos(angle)
      local pz = center.z + radius * math.sin(angle)
      table.insert(points, { x = px, y = center.y, z = pz })
    end
    local order = { 1, 3, 5, 2, 4, 1 }
    for i = 1, #order - 1 do
      local p1 = points[order[i]]
      local p2 = points[order[i + 1]]
      for i = 1, #order - 1 do
        addLine({ points = { points[order[i]], points[order[i + 1]] }, color = color, thickness = thickness })
      end
    end
  elseif symbol == 'Circle' then
    color = 'Yellow'
    local radius = 2
    local segments = 24
    local points = {}
    for i = 0, segments do
      local angle = math.rad((360 / segments) * i)
      local px = center.x + radius * math.cos(angle)
      local pz = center.z + radius * math.sin(angle)
      table.insert(points, { x = px, y = center.y, z = pz })
    end
    for i = 1, #points - 1 do
      addLine({ points = { points[i], points[i + 1] }, color = color, thickness = thickness })
    end
  elseif symbol == 'Diamond' then
    color = 'Green'
    local size = 2
    local p1 = { x = center.x, y = center.y, z = center.z - size }
    local p2 = { x = center.x + size, y = center.y, z = center.z }
    local p3 = { x = center.x, y = center.y, z = center.z + size }
    local p4 = { x = center.x - size, y = center.y, z = center.z }
    addLine({ points = { p1, p2 }, color = color, thickness = thickness })
    addLine({ points = { p2, p3 }, color = color, thickness = thickness })
    addLine({ points = { p3, p4 }, color = color, thickness = thickness })
    addLine({ points = { p4, p1 }, color = color, thickness = thickness })
  elseif symbol == 'Square' then
    local color = { 1, 0, 0 }
    local size = 2
    local p1 = { x = center.x - size, y = center.y, z = center.z - size }
    local p2 = { x = center.x + size, y = center.y, z = center.z - size }
    local p3 = { x = center.x + size, y = center.y, z = center.z + size }
    local p4 = { x = center.x - size, y = center.y, z = center.z + size }
    addLine({ points = { p1, p2 }, color = color, thickness = thickness })
    addLine({ points = { p2, p3 }, color = color, thickness = thickness })
    addLine({ points = { p3, p4 }, color = color, thickness = thickness })
    addLine({ points = { p4, p1 }, color = color, thickness = thickness })
  elseif symbol == 'Heart' then
    color = { 1, 0.5, 0.5 }
    local size = 1.5
    local steps = 32
    local points = {}
    for i = 0, steps do
      local t = (i / steps) * 2 * math.pi
      local x = size * 16 * math.sin(t) ^ 3 / 16
      local z = -size * (13 * math.cos(t) - 5 * math.cos(2 * t) - 2 * math.cos(3 * t) - math.cos(4 * t)) / 16
      table.insert(points, { x = center.x + x, y = center.y, z = center.z + z })
    end
    for i = 1, #points - 1 do
      addLine({ points = { points[i], points[i + 1] }, color = color, thickness = thickness })
    end
  elseif symbol == 'Triangle' then
    color = { 0, 0, 0.8 }
    local size = 2
    local p1 = { x = center.x, y = center.y, z = center.z - size }
    local p2 = { x = center.x + size, y = center.y, z = center.z + size }
    local p3 = { x = center.x - size, y = center.y, z = center.z + size }
    addLine({ points = { p1, p2 }, color = color, thickness = thickness })
    addLine({ points = { p2, p3 }, color = color, thickness = thickness })
    addLine({ points = { p3, p1 }, color = color, thickness = thickness })
  else
    error('Not managed symbol', 2)
  end

  -- actualizar
  Global.setVectorLines(allLines)
  return lineIndexes
end

function removeLines(indexes)
  if type(indexes) ~= "table" then return end

  local lines = Global.getVectorLines() or {}
  if #lines == 0 then return end

  -- mark indexes to remove
  local toRemove = {}
  for _, idx in ipairs(indexes) do
    toRemove[idx] = true
  end

  -- rebuild the list with only remaining lines
  local remaining = {}
  for i, line in ipairs(lines) do
    if not toRemove[i] then
      table.insert(remaining, line)
    end
  end

  Global.setVectorLines(remaining)
end

function getLocations(trait)
  assert(trait == 'Present' or trait == 'Ancient' or trait == nil, 'Error value in findLocations')
  local allObjects = getAllObjects()
  local locations = {}
  for _, object in ipairs(allObjects) do
    local rawNotes = object.getGMNotes() or "{}"
    local metadata = JSON.decode(rawNotes) or {}
    if PlayAreaApi.isInPlayArea(object) and metadata['type'] == 'Location' then
      local descripcion = object.getDescription() or ""
      if trait == nil then
        table.insert(locations, object)
      elseif trait ~= nil and string.find(descripcion, trait) then
        table.insert(locations, object)
      end
    end
  end
  return locations
end

function getSymbol(obj)
  -- It returns the symbol of a location, if it not a location, it returns nil
  -- This works even for an object inside a deck
  local rawNotes = nil
  if type(obj) == 'table' then -- This object is inside a deck
    rawNotes = obj.gm_notes or "{}"
  else
    rawNotes = obj.getGMNotes() or "{}"
  end
  local md = JSON.decode(rawNotes) or {}
  if md['type'] ~= 'Location' then
    return nil
  end
  local lf = md['locationFront']
  if not lf then return nil end
  local symbol = lf["icons"] or nil
  return symbol
end

function onLoadTests()
  -- getSymbol(getObjectFromGUID("c8f441"))
  -- getSymbol(getObjectFromGUID("d71f61"))
  -- getSymbol(getObjectFromGUID("158c7c"))
  -- getSymbol(getObjectFromGUID("941f46"))
  -- getSymbol(getObjectFromGUID("22f371"))
  -- getSymbol(getObjectFromGUID("db1ed3"))
  -- log('END OF TEST 1')

  -- toggleIndividualHelpers()
  -- log('END OF TEST 2')

  -- Wait.frames(function()
  --   toggleIndividualHelpers()
  -- end, 140)
  -- log('END OF TEST 3')

  -- toggleMarkSymbols()
  -- log('END OF TEST')

  -- Wait.frames(function()
  --   placeActAgenda3()
  -- end, 150)
end

function append(table1, table2)
  -- Returns a new table
  assert(type(table1) == 'table', 'Type error 1')
  assert(type(table2) == 'table', 'Type error 2')
  for _, el in ipairs(table2) do
    table.insert(table1, el)
  end
  return table1
end

function getExplorationDeck(explorerHelper)
  local objects = SearchLib.onObject(explorerHelper)
  for _, object in ipairs(objects) do
    if object.tag == 'Deck' and object.is_face_down then
      return object
    end
  end
  return nil
end

function liftObjects(objects, height)
  height = height or 3

  for _, obj in ipairs(objects) do
    if obj and obj.getPosition then
      local pos = obj.getPosition()
      obj.setPositionSmooth({
        pos.x,
        pos.y + height,
        pos.z
      })
    end
  end
end

function cardHasClues(card)
  local searchResult = SearchLib.onObject(card, "isClue")
  return #searchResult > 0
end
