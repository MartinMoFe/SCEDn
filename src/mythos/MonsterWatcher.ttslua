local GUIDReferenceApi = require("core/GUIDReferenceApi")
local PlayermatApi     = require("playermat/PlayermatApi")
local SearchLib        = require("util/SearchLib")
local Zones            = require("playermat/Zones")

-- FIND ENEMIES: Cards that are enemies only only when face-down
-- Here we list them by their id in the metadata
-- These cases are explicitly defined here because they are not in the metadata
FaceDownEnemies        = { -- Some enemies are Agenda or Act cards that are Enemies in the metadata
    ['04137a'] = true,     -- Maria DeSilva
    ['04122'] = true,      -- Harlan Earstone
    ['04130a'] = true,     -- Henry Deveau
    ['04209'] = true,      -- The Winged Serpent
}
AgendaFacedownEnemies  = { -- Some enemies are Agenda or Act cards
    ["03241"] = true,      -- Empire of the Dead
    ['01121a'] = true,     -- The Masked Hunter
    ['50026a'] = true,     -- Nagorath
    ['11537a'] = true,     -- Seafloor Leviathan
}


---------------------------
--- CONSTANTS
------------------------------

local BLUE_ENEMY       = { r = 0.267, g = 0.667, b = 0.731 }


-- █▀▀ █▀▀█ █▀▀▄ █▀▀
-- █── █──█ █──█ █▀▀
-- ▀▀▀ ▀▀▀▀ ▀▀▀─ ▀▀▀

function onLoad(savedData)
    self.interactable = true
    lastPhase         = nil
    newPhase          = nil
    fakeMinis         = {}

    timerID           = Wait.time(scanGameChange, 1.2, -1)

    self.addContextMenuItem("Disable Monster Watcher", function(playerColor)
        destroyMonsterWatcher()
    end)
end

function destroyMonsterWatcher()
    if timerID then
        Wait.stop(timerID)
        timerID = nil
    end

    printToAll("Monster Watcher was disabled.", { 1, 0.2, 0.2 })
    self.destruct()
end

function onDestroy()
    if timerID then
        Wait.stop(timerID)
        timerID = nil
    end
end

function scanGameChange()
    local phaseTracker = getObjectByName('Phase Tracker')

    if not phaseTracker then
        log('Not phase tracker')
        Wait.stop(timerID)
        broadcastToAll('Destroyed watcher', 'Red')
        self.destruct()
    end

    newPhase = phaseTracker.getVar('phaseId')

    if newPhase == lastPhase then
        return
    end

    lastPhase = newPhase
    if newPhase == 2 then
        duplicateFakeMinis()
    elseif newPhase == 3 then
        destroyFakeMinis()
        showEnemyInfo(BLUE_ENEMY, 'Green')
    end
end

-- This function shows how many enemies are in play area and in the threat areas
function showEnemyInfo(colorPrint, colorHighlight)

    local enemiesInPlayArea = getEnemiesInPlayArea()
    local matColors = PlayermatApi.getUsedMatColors()
    local enemiesInThreatArea = {}
    for _, matColor in ipairs(matColors) do
        local adding = getEnemiesInThreatArea(matColor)
        for _, element in ipairs(adding) do table.insert(enemiesInThreatArea, element) end
    end

    local num = #enemiesInPlayArea
    if num > 1 then
        printToAll('There are ' .. tostring(num) .. ' enemies in the map.', colorPrint)
    elseif num == 1 then
        printToAll('There is ' .. tostring(num) .. ' enemy in the map.', colorPrint)
    end
    highlightObjects(enemiesInPlayArea, colorHighlight, 10)
    local num = #enemiesInThreatArea
    if num > 1 then
        printToAll('There are ' .. tostring(num) .. ' enemies engaged.', colorPrint)
    elseif num == 1 then
        printToAll('There is ' .. tostring(num) .. ' enemy engaged.', colorPrint)
    end
    highlightObjects(enemiesInThreatArea, colorHighlight, 10)
end

-- Threat area helper

function getThreatAreaPositions(matColor)
    -- Returns a table with Vectors
    local positions = {}

    for i = 1, 4 do
        local position = Zones.getZonePosition(matColor, "Threat" .. i)
        table.insert(positions, position)
    end

    return positions
end

function getThreatAreaObjects(matColor)
    -- Returns a table of objects
    local objects = {}
    for _, pos in ipairs(getThreatAreaPositions(matColor)) do
        local thisObj = SearchLib.atPosition(pos, "isCardOrDeck")
        if #thisObj > 0 then
            table.insert(objects, thisObj[1])
        end
    end
    return objects
end

function getEnemiesInThreatArea(matColor)
    -- returns a table of objects
    -- only enemies that are face up (some custom scenarios can make you draw facedown enemies)
    local enemies = {}
    colors = {}
    if matColor == 'All' then
        colors = Player.getAvailableColors()
    else
        colors = { matColor }
    end

    for _, color in ipairs(colors) do
        local threats = getThreatAreaObjects(color)
        for _, obj in ipairs(threats) do
            if isVisibleEnemy(obj) then table.insert(enemies, obj) end
        end
    end
    return enemies
end

function getSingleEnemy()
    -- If there is only one enemy in play area, return it
    local enemies = getEnemiesInPlayArea()
    if #enemies == 1 then
        return enemies[1]
    end
    return nil
end

-- PlayArea helper

function scanPlayArea()
    -- Returns all objects in the PlayArea (the central zone)
    local zone = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "PlayAreaZone")

    if not zone then
        return
    end

    return zone.getObjects()
end

function getEnemiesInPlayArea()
    -- returns a table of objects
    local enemies = {}
    local objs = scanPlayArea()
    for _, obj in ipairs(objs) do
        if isVisibleEnemy(obj) then
            table.insert(enemies, obj)
        end
    end
    return enemies
end

-- Minis helper

function getMinicardsInPlayArea()
    -- returns a table of objects
    local minis = {}
    local objs = scanPlayArea()
    for _, obj in ipairs(objs) do
        if obj.hasTag("Minicard") then
            table.insert(minis, obj)
        end
    end
    return minis
end

function duplicateFakeMinis()
    fakeMinis = {}

    for _, obj in ipairs(getMinicardsInPlayArea()) do
        local data = obj.getData()

        local s = obj.getScale()

        data.Scale = {
            x = s.x * 0.8,
            y = s.y * 0.8,
            z = s.z * 0.8,
        }

        local pos = obj.getPosition()
        pos.y = pos.y - 0.05

        data.Tags = data.Tags or {}
        for i = #data.Tags, 1, -1 do
            if data.Tags[i] == "Minicard" then
                table.remove(data.Tags, i)
            end
        end

        table.insert(data.Tags, "DuplicateMinicard")

        local dup = spawnObjectData({
            data = data,
            position = obj.getPosition(),
            rotation = { 0, 270, 180 }
        })
        dup.interactable = false

        table.insert(fakeMinis, dup)
    end
end

function destroyFakeMinis()
    if not fakeMinis then return end

    for i, obj in ipairs(fakeMinis) do
        if obj and obj.destruct then
            obj:destruct()
        end
    end

    -- reset the table
    fakeMinis = {}
end

-- Identify card wisely

function isVisibleEnemy(obj)
    -- Receives an object, takes its metadata and checks if it's an faceup or visible enemy
    -- This is a long function, because it checks the type of the card
    -- And if its visible, and there are many strange combinations
    -- Returns boolean
    local md = getMd(obj)
    local type = md['type'] or ''
    if type == 'Location' then
        -- most objects in the playarea are objects, the fastest is to say false immediately
        return false
    elseif type == 'Enemy' and not obj.is_face_down then
        return true
    elseif type == 'Enemy' and obj.is_face_down then
        local id = md['id'] or ''
        if FaceDownEnemies[id] then return true end
        return false
    elseif type == 'Agenda' and obj.is_face_down then
        local id = md['id'] or ''
        return AgendaFacedownEnemies[id] or false
    end

    return false
end

--------------------
-- Generic
--------------------

function highlightObjects(objects, color, duration)
    for _, obj in ipairs(objects) do
        obj.highlightOn(color, duration)
    end
end

function highlightObjectsCall(params)
    local objects = params.objects
    local color = params.color
    local duration = params.duration
    highlightObjects(objects, color, duration)
end

---Find the first object whose name matches.
---Case-sensitive by default.
---@param name string
---@param opts table|nil  -- { caseInsensitive = true }
---@return tts__Object|nil
function getObjectByName(name, opts)
    assert(name, "getObjectByName: name is required")
    opts = opts or {}

    local target = name
    local caseInsensitive = opts.caseInsensitive == true

    if caseInsensitive then
        target = string.lower(name)
    end

    for _, obj in ipairs(getAllObjects()) do
        local objName = obj.getName() or ""

        if caseInsensitive then
            if string.lower(objName) == target then
                return obj
            end
        else
            if objName == target then
                return obj
            end
        end
    end

    return nil
end

---Safely read GM notes JSON and return a table (never nil).
---@param obj tts__Object
---@return table
function getMd(obj)
    assert(obj, "getMd: obj is required")

    local raw = obj.getGMNotes() or ""

    if raw == "" then
        return {}
    end

    local ok, data = pcall(JSON.decode, raw)

    if not ok or type(data) ~= "table" then
        return {}
    end

    return data
end

