local GUIDReferenceApi      = require("core/GUIDReferenceApi")
local PlayermatApi          = require("playermat/PlayermatApi")
local SearchLib             = require("util/SearchLib")
local Zones                 = require("playermat/Zones")

-- FIND ENEMIES: Cards that are enemies only only when face-down
-- Here we list them by their id in the metadata
-- These cases are explicitly defined here because they are not in the metadata
local FaceDownEnemies       = {  -- Some enemies are Agenda or Act cards that are Enemies in the metadata
    ['04137a'] = true,           -- Maria DeSilva
    ['04122'] = true,            -- Harlan Earstone
    ['04130a'] = true,           -- Henry Deveau
    ['04209'] = true,            -- The Winged Serpent
    ['53046'] = true,           -- The Winged Serpent Return
}
local AgendaFacedownEnemies = {  -- Some enemies are Agenda or Act cards
    ["03241"] = true,            -- Empire of the Dead
    ['01121a'] = true,           -- The Masked Hunter
    ['50026a'] = true,           -- Nagorath
    ['11537a'] = true,           -- Seafloor Leviathan
}


---------------------------
--- CONSTANTS
------------------------------

local BLUE_ENEMY = { r = 0.267, g = 0.667, b = 0.731 }


-- █▀▀ █▀▀█ █▀▀▄ █▀▀
-- █── █──█ █──█ █▀▀
-- ▀▀▀ ▀▀▀▀ ▀▀▀─ ▀▀▀

function onLoad(savedData)
    self.interactable = true
    lastPhase         = nil
    newPhase          = nil
    fakeMinis         = {}
    enemies           = {}
    treacheries       = {}
    enemiesT          = {}
    treacheriesT      = {}
end

function respondToChange(phase)
    -- This function is called from outside
    newPhase = phase

    if newPhase == lastPhase then
        return
    end

    lastPhase = newPhase
    if newPhase == 2 then
        showHealthSanityInfo()
        destroyFakeMinis()
        duplicateFakeMinis()
    elseif newPhase == 3 then
        destroyFakeMinis()
        showEnemyInfo(BLUE_ENEMY, BLUE_ENEMY)
    elseif newPhase == 4 then
        destroyFakeMinis()
    elseif newPhase == 1 then
        destroyFakeMinis()
        showHealthSanityInfo()
    end
end

-- This function shows how many enemies are in play area and in the threat areas
function showEnemyInfo(colorPrint, colorHighlight)
    scanAndStore()

    local enemiesInPlayArea = enemies or {}
    local num = #enemiesInPlayArea
    if num > 1 then
        printToAll('There are ' .. tostring(num) .. ' enemies in the map.', colorPrint)
    elseif num == 1 then
        printToAll('There is ' .. tostring(num) .. ' enemy in the map.', colorPrint)
    end
    highlightObjects(enemiesInPlayArea, colorHighlight, 10)

    local enemiesInThreatArea = enemiesT
    num = #enemiesInThreatArea
    if num > 1 then
        printToAll('There are ' .. tostring(num) .. ' enemies engaged.', colorPrint)
    elseif num == 1 then
        printToAll('There is ' .. tostring(num) .. ' enemy engaged.', colorPrint)
    end
    highlightObjects(enemiesInThreatArea, colorHighlight, 10)
end

function showHealthSanityInfo()
    if type(PlayermatApi) ~= "table" then
        log("[EnemyWatcher][ERROR] PlayermatApi missing or invalid")
        return
    end

    if type(PlayermatApi.getUsedMatColors) ~= "function" then
        log("[EnemyWatcher][ERROR] getUsedMatColors not found")
        return
    end

    if type(PlayermatApi.getCounterValue) ~= "function" then
        log("[EnemyWatcher][ERROR] getCounterValue not found")
        return
    end

    local usedColors = PlayermatApi.getUsedMatColors()
    if type(usedColors) ~= "table" then
        log("[EnemyWatcher][ERROR] getUsedMatColors did not return a table")
        return
    end

    for _, matColor in ipairs(usedColors) do
        if type(matColor) ~= "string" then
            log("[EnemyWatcher][ERROR] matColor is not a string")
            return
        end

        local investigatorName = PlayermatApi.getInvestigatorName(matColor)
        if type(investigatorName) ~= "string" then
            log("[EnemyWatcher][ERROR] Invalid investigator name for matColor " .. matColor)
            return
        end

        local health = PlayermatApi.getCounterValue(matColor, "DamageCounter")
        if type(health) ~= "number" then
            log("[EnemyWatcher][ERROR] Invalid health counter for " .. investigatorName)
            return
        end

        local sanity = PlayermatApi.getCounterValue(matColor, "HorrorCounter")
        if type(sanity) ~= "number" then
            log("[EnemyWatcher][ERROR] Invalid sanity counter for " .. investigatorName)
            return
        end

        local message = "[" ..
        Color.fromString(matColor):toHex() ..
        "]" .. investigatorName .. "[-]" .. ": Damage " .. health .. " / Horror " .. sanity

        printToAll(message)
    end
end

-- Threat area helper

function getThreatAreaPositions(matColor)
    assert(type(matColor) == "string", "matColor must be a string")

    local valid = {
        White  = true,
        Green  = true,
        Red    = true,
        Orange = true
    }

    assert(valid[matColor], "matColor must be one of: White, Green, Red, Orange")
    -- Returns a table with Vectors
    local positions = {}

    for i = 1, 4 do
        local position = Zones.getZonePosition(matColor, "Threat" .. i)
        table.insert(positions, position)
    end

    return positions
end

function getThreatAreaObjects(matColor)
    -- Returns a table of objects
    local objects = {}
    for _, pos in ipairs(getThreatAreaPositions(matColor)) do
        local thisObj = SearchLib.atPosition(pos, "isCardOrDeck")
        if #thisObj > 0 then
            table.insert(objects, thisObj[1])
        end
    end
    return objects
end

-- PlayArea helper

-- Scans the central PlayArea zone and returns all objects within it.
-- @return {table} Table of GameObject references in the zone
function scanPlayArea()
    -- Returns all objects in the PlayArea (the central zone)
    local zone = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "PlayAreaZone")

    if not zone then
        log("[EnemyWatcher][ERROR] PlayAreaZone not found")
        return {}
    end

    return zone.getObjects()
end

-- @return table Table containing all GameObject references from all threat areas
-- @usage local threatObjects = scanThreatAreas()
function scanThreatAreas()
    local matColors = PlayermatApi.getUsedMatColors()
    if type(matColors) ~= "table" then return {} end

    local objectsInThreat = {}
    for _, matColor in ipairs(matColors) do
        local adding = getThreatAreaObjects(matColor)
        for _, element in ipairs(adding) do table.insert(objectsInThreat, element) end
    end
    return objectsInThreat
end

--- Scans the Play Area and updates cached enemy and treachery lists.
--- Populates the globals:
---   enemies      : tts__Object[]
---   treacheries  : tts__Object[]
function scanAndStore()
    assert(type(isVisibleTreachery) == "function", "isVisibleTreachery missing")
    enemies = {}
    treacheries = {}

    local objs = scanPlayArea()
    if not objs then return end

    for _, obj in ipairs(objs) do
        if isVisibleEnemy(obj) then
            table.insert(enemies, obj)
        elseif isVisibleTreachery(obj) then
            table.insert(treacheries, obj)
        end
    end

    enemiesT = {}
    treacheriesT = {}

    local objs = scanThreatAreas()
    if not objs then return end

    for _, obj in ipairs(objs) do
        if isVisibleEnemy(obj) then
            table.insert(enemiesT, obj)
        elseif isVisibleTreachery and isVisibleTreachery(obj) then
            table.insert(treacheriesT, obj)
        end
    end
end

-- Minis helper

function getMinicardsInPlayArea()
    -- returns a table of objects
    local minis = {}
    local objs = scanPlayArea()
    for _, obj in ipairs(objs) do
        if obj.hasTag("Minicard") then
            table.insert(minis, obj)
        end
    end
    return minis
end

function duplicateFakeMinis()
    for _, obj in ipairs(getMinicardsInPlayArea()) do
        local data = obj.getData()

        local s = obj.getScale()
        local newScale = {
            x = s.x * 0.8,
            y = s.y * 0.8,
            z = s.z * 0.8,
        }


        local pos = obj.getPosition()
        pos.y = pos.y - 0.02

        data.Tags = data.Tags or {}
        for i = #data.Tags, 1, -1 do
            if data.Tags[i] == "Minicard" then
                table.remove(data.Tags, i)
            end
        end
        table.insert(data.Tags, "DuplicateMinicard")


        local dup = spawnObjectData({
            data = data,
            position = pos,
            rotation = { 0, 270, 180 },
            scale = newScale
        })

        dup.interactable = false
        dup.setLock(true)

        table.insert(fakeMinis, dup)
    end
end

function destroyFakeMinis()
    if not fakeMinis then return end

    for i, obj in ipairs(fakeMinis) do
        if obj and obj.destruct then
            obj:destruct()
        end
    end

    fakeMinis = {}
end

-- Identify card wisely

--- Determines whether an object represents a visible enemy.
--- Face-down enemies may still be visible depending on metadata tables.
---@param obj tts__Object
---@return boolean
function isVisibleEnemy(obj)
    -- Receives an object, takes its metadata and checks if it's an faceup or visible enemy
    -- This is a long function, because it checks the type of the card
    -- And if its visible, and there are many strange combinations
    -- Returns boolean
    local md = getMd(obj)
    local type = md['type'] or ''
    if type == 'Location' then
        -- most objects in the playarea are objects, the fastest is to say false immediately
        return false
    elseif type == 'Enemy' and not obj.is_face_down then
        return true
    elseif type == 'Enemy' and obj.is_face_down then
        local id = md['id'] or ''
        if FaceDownEnemies[id] then return true end
        return false
    elseif type == 'Agenda' and obj.is_face_down then
        local id = md['id'] or ''
        return AgendaFacedownEnemies[id] or false
    end

    return false
end

--- Determines whether an object represents a visible treachery card.
---@param obj tts__Object
---@return boolean
function isVisibleTreachery(obj)
    if not obj then return false end

    local md = getMd(obj)
    return md.type == "Treachery" and not obj.is_face_down
end

function isFaceupLocation(obj)
    local rawNotes = obj.getGMNotes() or "{}"
    local md = JSON.decode(rawNotes) or {}
    local id = md['id'] or ''
    local type = md['type'] or ''
    if type == 'Location' and not obj.is_face_down then
        return true
    elseif type == 'Agenda' then
        -- some locations might be in the agenda
        -- yet to implement
        return false
    end
end

function isFacedownLocation(obj)
    local rawNotes = obj.getGMNotes() or "{}"
    local md = JSON.decode(rawNotes) or {}
    local id = md['id'] or ''
    local type = md['type'] or ''
    if type == 'Location' and obj.is_face_down then
        return true
    end
end

--------------------
-- Generic
--------------------

---@param objects tts__Object[]   # list of objects to highlight
---@param color string|table      # TTS color string, e.g. "Red", "Green", "Blue", or hex
---@param duration number         # seconds the highlight lasts
function highlightObjects(objects, color, duration)
    assert(type(objects) == "table", "highlightObjects: objects must be a table")
    assert(type(duration) == "number", "highlightObjects: duration must be a number")

    for i, obj in ipairs(objects) do
        obj.highlightOn(color, duration)
    end
end

function highlightObjectsCall(params)
    local objects = params.objects
    local color = params.color
    local duration = params.duration
    highlightObjects(objects, color, duration)
end

---Find the first object whose name matches.
---Case-sensitive by default.
---@param name string
---@return tts__Object|nil
function getObjectByName(name)
    assert(name, "getObjectByName: name is required")
    local target = name
    for _, obj in ipairs(getAllObjects()) do
        local objName = obj.getName() or ""
        if objName == target then
            return obj
        end
    end
    return nil
end

---Safely read GM notes JSON and return a table (never nil).
---@param obj tts__Object
---@return table
function getMd(obj)
    assert(obj, "getMd: obj is required")

    local raw = obj.getGMNotes() or ""

    if raw == "" then
        return {}
    end

    local ok, data = pcall(JSON.decode, raw)

    if not ok or type(data) ~= "table" then
        return {}
    end

    return data
end
